
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>commands: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/hulutech-web/goravel-kit-cli/internal/commands/new.go (13.7%)</option>
				
				<option value="file1">github.com/hulutech-web/goravel-kit-cli/internal/utils/cmd.go (100.0%)</option>
				
				<option value="file2">github.com/hulutech-web/goravel-kit-cli/internal/utils/file.go (100.0%)</option>
				
				<option value="file3">github.com/hulutech-web/goravel-kit-cli/internal/utils/git.go (0.0%)</option>
				
				<option value="file4">github.com/hulutech-web/goravel-kit-cli/internal/utils/network.go (0.0%)</option>
				
				<option value="file5">github.com/hulutech-web/goravel-kit-cli/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package commands

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/fatih/color"

        "github.com/hulutech-web/goravel-kit-cli/internal/utils"
        "github.com/urfave/cli/v2"
)

// æ·»åŠ ç‰ˆæƒä¿¡æ¯æ˜¾ç¤ºå‡½æ•°
func printWelcomeBanner(projectName string) <span class="cov0" title="0">{
        cyan := color.New(color.FgCyan, color.Bold)
        green := color.New(color.FgGreen, color.Bold)
        yellow := color.New(color.FgYellow, color.Bold)
        fmt.Printf("\n")
        fmt.Printf("\n")
        cyan.Println(" â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ          â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ ")
        cyan.Println("â–ˆâ–ˆ       â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ          â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ        â–ˆâ–ˆ      â–ˆâ–ˆ      â–ˆâ–ˆ ")
        cyan.Println("â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ    â–ˆâ–ˆ        â–ˆâ–ˆ      â–ˆâ–ˆ      â–ˆâ–ˆ ")
        cyan.Println("â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ          â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ        â–ˆâ–ˆ      â–ˆâ–ˆ      â–ˆâ–ˆ ")
        cyan.Println(" â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ ")
        cyan.Println("         ")
        green.Println("                    +++++++++++++++++++ğŸ‰æ¬¢è¿ä½¿ç”¨ Goravel Kit CLI ğŸ†+++++++++++++++++++")
        yellow.Printf("                    |Â·&lt;&lt;è¾¾å·è‘«èŠ¦ç§‘æŠ€&gt;&gt;ç ”å‘\n")
        yellow.Printf("                    |Â·ä½œè€…: yuanhaozhuzhu@hotmail.com\n")
        yellow.Printf("                    |Â·å¼€å‘æ—¶é—´: 2025-08-22\n")
        yellow.Printf("                    |Â·ç‰ˆæœ¬å·: v1.0.0\n")
        yellow.Printf("                    |Â·ç‰ˆæœ¬è¯´æ˜: Goravel é¡¹ç›®è„šæ‰‹æ¶å·¥å…·\n")
        yellow.Printf("                    |Â·ç‰ˆæœ¬æ—¶é—´: 2025-08-22\n")
        cyan.Println("                    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")

        fmt.Printf("\n")
        color.New(color.FgHiWhite, color.Bold).Printf("ğŸš€ å¼€å§‹åˆ›å»º Goravel é¡¹ç›®: %s\n", projectName)
        fmt.Printf("\n")
}</span>

var NewCommand = &amp;cli.Command{
        Name:      "new",
        Usage:     "Create a new Goravel application from template",
        ArgsUsage: "&lt;project-name&gt;",
        Action:    createNewProject,
        Flags: []cli.Flag{
                &amp;cli.BoolFlag{
                        Name:  "force",
                        Usage: "Force create project even if directory exists",
                },
                &amp;cli.StringFlag{
                        Name:  "branch",
                        Usage: "Git branch to use",
                        Value: "master",
                },
                &amp;cli.BoolFlag{
                        Name:  "verbose",
                        Usage: "Show verbose output",
                },
                &amp;cli.BoolFlag{
                        Name:  "ssh",
                        Usage: "Use SSH URL instead of HTTPS",
                        Value: true, // é»˜è®¤å¯ç”¨ SSH
                },
                &amp;cli.BoolFlag{
                        Name:  "https",
                        Usage: "Use HTTPS URL instead of SSH",
                        Value: false,
                },
                &amp;cli.DurationFlag{
                        Name:  "timeout",
                        Usage: "Timeout for download operation",
                        Value: 3 * time.Minute,
                },
                &amp;cli.BoolFlag{
                        Name:  "no-banner",
                        Usage: "Don't show welcome banner",
                },
                &amp;cli.BoolFlag{
                        Name:  "gitee-only",
                        Usage: "Use Gitee mirror only (skip GitHub)",
                },
                &amp;cli.BoolFlag{
                        Name:  "github-only",
                        Usage: "Use GitHub only (skip Gitee fallback)",
                },
        },
}

func createNewProject(c *cli.Context) error <span class="cov0" title="0">{
        if c.Args().Len() &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("project name is required\nUsage: goravel-kit-cli new &lt;project-name&gt;")
        }</span>

        <span class="cov0" title="0">projectName := c.Args().First()
        branch := c.String("branch")
        force := c.Bool("force")
        verbose := c.Bool("verbose")
        useSSH := c.Bool("ssh")
        useHTTPS := c.Bool("https")
        timeout := c.Duration("timeout")
        noBanner := c.Bool("no-banner")
        giteeOnly := c.Bool("gitee-only")
        githubOnly := c.Bool("github-only")

        // å¤„ç†åè®®é€‰æ‹©é€»è¾‘ï¼šå¦‚æœåŒæ—¶æŒ‡å®šäº† --httpsï¼Œä¼˜å…ˆä½¿ç”¨ HTTPS
        var protocol string
        if useHTTPS </span><span class="cov0" title="0">{
                protocol = "https"
                useSSH = false
        }</span> else<span class="cov0" title="0"> {
                protocol = "ssh"
                useSSH = true
        }</span>

        // æ˜¾ç¤ºç‰ˆæƒä¿¡æ¯ï¼ˆé™¤éæŒ‡å®šä¸æ˜¾ç¤ºï¼‰
        <span class="cov0" title="0">if !noBanner </span><span class="cov0" title="0">{
                printWelcomeBanner(projectName)
        }</span> else<span class="cov0" title="0"> {
                color.New(color.FgHiWhite, color.Bold).Printf("ğŸš€ Creating Goravel project: %s\n", projectName)
                fmt.Printf("\n")
        }</span>

        // æ™ºèƒ½é€‰æ‹©é•œåƒæºç­–ç•¥
        <span class="cov0" title="0">var autoDetectedGiteeOnly bool
        var networkStatus string

        // å¦‚æœä¸æ˜¯å¼ºåˆ¶æŒ‡å®šäº†é•œåƒæºï¼Œå°±è‡ªåŠ¨æ£€æµ‹ç½‘ç»œ
        if !giteeOnly &amp;&amp; !githubOnly </span><span class="cov0" title="0">{
                color.New(color.FgHiCyan).Printf("ğŸŒ æ£€æµ‹ç½‘ç»œè¿æ¥...\n")

                if utils.CheckGiteeAccess() </span><span class="cov0" title="0">{
                        networkStatus = "Gitee è®¿é—®æ­£å¸¸"
                        autoDetectedGiteeOnly = true
                        // è‡ªåŠ¨å¯ç”¨ gitee-only æ¨¡å¼
                        giteeOnly = true
                }</span> else<span class="cov0" title="0"> {
                        networkStatus = "GitHub è®¿é—®å¤±è´¥ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ° GitHub"
                        autoDetectedGiteeOnly = true
                }</span>
                <span class="cov0" title="0">color.New(color.FgHiCyan).Printf("   %s\n", networkStatus)</span>
        }

        // å®šä¹‰é•œåƒæº
        <span class="cov0" title="0">mirrors := []struct {
                name    string
                url     string
                sshURL  string
                enabled bool
        }{
                {
                        name:    "GitHub",
                        url:     "https://github.com/hulutech-web/goravel-kit.git",
                        sshURL:  "git@github.com:hulutech-web/goravel-kit.git",
                        enabled: !giteeOnly,
                },
                {
                        name:    "Gitee",
                        url:     "https://gitee.com/hulutech/goravel-kit.git",
                        sshURL:  "git@gitee.com:hulutech/goravel-kit.git",
                        enabled: !githubOnly,
                },
        }

        // æ˜¾ç¤ºå½“å‰ä½¿ç”¨çš„é•œåƒæºç­–ç•¥
        color.New(color.FgHiBlue).Printf("ğŸ“¦ æ¨¡æ¿ç­–ç•¥: ")
        switch </span>{
        case giteeOnly &amp;&amp; autoDetectedGiteeOnly:<span class="cov0" title="0">
                color.New(color.FgHiBlue).Printf("è‡ªåŠ¨é€‰æ‹© Gitee é•œåƒ (ç½‘ç»œæ£€æµ‹)\n")</span>
        case giteeOnly:<span class="cov0" title="0">
                color.New(color.FgHiBlue).Printf("å¼ºåˆ¶ä½¿ç”¨ Gitee é•œåƒ (ç”¨æˆ·æŒ‡å®š)\n")</span>
        case githubOnly:<span class="cov0" title="0">
                color.New(color.FgHiBlue).Printf("å¼ºåˆ¶ä½¿ç”¨ GitHub é•œåƒ (ç”¨æˆ·æŒ‡å®š)\n")</span>
        default:<span class="cov0" title="0">
                color.New(color.FgHiBlue).Printf("è‡ªåŠ¨é€‰æ‹©é•œåƒ (GitHub â†’ Gitee)\n")</span>
        }

        <span class="cov0" title="0">color.New(color.FgHiBlue).Printf("ğŸŒ¿ åˆ†æ”¯: %s\n", branch)
        color.New(color.FgHiBlue).Printf("ğŸ”— åè®®: %s (é»˜è®¤)\n", protocol)

        if verbose </span><span class="cov0" title="0">{
                color.New(color.FgHiMagenta).Printf("ğŸ“¡ å¯ç”¨é•œåƒæº:\n")
                for _, mirror := range mirrors </span><span class="cov0" title="0">{
                        if mirror.enabled </span><span class="cov0" title="0">{
                                var url string
                                if useSSH </span><span class="cov0" title="0">{
                                        url = mirror.sshURL
                                }</span> else<span class="cov0" title="0"> {
                                        url = mirror.url
                                }</span>
                                <span class="cov0" title="0">color.New(color.FgHiMagenta).Printf("   - %s: %s\n", mirror.name, url)</span>
                        }
                }
                <span class="cov0" title="0">color.New(color.FgHiYellow).Printf("â±ï¸  è¶…æ—¶æ—¶é—´: %v\n", timeout)</span>
        }

        // æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
        <span class="cov0" title="0">if utils.DirectoryExists(projectName) &amp;&amp; !force </span><span class="cov0" title="0">{
                return fmt.Errorf("âŒ ç›®å½• '%s' å·²å­˜åœ¨ã€‚ä½¿ç”¨ --force å‚æ•°è¦†ç›–", projectName)
        }</span>

        // åˆ›å»ºä¸´æ—¶ç›®å½•
        <span class="cov0" title="0">tempDir, err := os.MkdirTemp("", "goravel-kit-*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("âŒ åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := os.RemoveAll(tempDir); err != nil &amp;&amp; verbose </span><span class="cov0" title="0">{
                        color.New(color.FgHiRed).Printf("âš ï¸  è­¦å‘Š: æ¸…ç†ä¸´æ—¶ç›®å½•å¤±è´¥: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">var downloadError error
        var successMirror string
        var successRepoURL string

        // å°è¯•ä»å„ä¸ªé•œåƒæºä¸‹è½½
        for _, mirror := range mirrors </span><span class="cov0" title="0">{
                if !mirror.enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                // é€‰æ‹© URLï¼ˆé»˜è®¤ä½¿ç”¨ SSHï¼‰
                <span class="cov0" title="0">var repoURL string
                if useSSH </span><span class="cov0" title="0">{
                        repoURL = mirror.sshURL
                }</span> else<span class="cov0" title="0"> {
                        repoURL = mirror.url
                }</span>

                <span class="cov0" title="0">color.New(color.FgHiGreen).Printf("\nğŸ“¥ å°è¯•ä» %s ä¸‹è½½æ¨¡æ¿...\n", mirror.name)
                color.New(color.FgHiCyan).Printf("   ğŸ“ ä»“åº“: %s\n", repoURL)
                color.New(color.FgHiCyan).Printf("   ğŸŒ¿ åˆ†æ”¯: %s\n", branch)

                // ä½¿ç”¨å¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡
                ctx, cancel := context.WithTimeout(context.Background(), timeout)

                // ä¸‹è½½æ¨¡æ¿
                err := utils.CloneRepositoryWithContext(ctx, repoURL, branch, tempDir, verbose)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        downloadError = err
                        color.New(color.FgHiRed).Printf("âŒ %s ä¸‹è½½å¤±è´¥: %v\n", mirror.name, err)

                        // å¦‚æœä¸æ˜¯æœ€åä¸€ä¸ªé•œåƒæºï¼Œç»§ç»­å°è¯•ä¸‹ä¸€ä¸ª
                        if hasNextMirror(mirrors, mirror.name) </span><span class="cov0" title="0">{
                                color.New(color.FgHiYellow).Printf("ğŸ”„ å°è¯•ä¸‹ä¸€ä¸ªé•œåƒæº...\n")
                                continue</span>
                        }
                } else<span class="cov0" title="0"> {
                        successMirror = mirror.name
                        successRepoURL = repoURL
                        downloadError = nil
                        break</span>
                }
        }

        // æ£€æŸ¥ä¸‹è½½ç»“æœ
        <span class="cov0" title="0">if downloadError != nil </span><span class="cov0" title="0">{
                color.New(color.FgHiRed).Printf("\nâŒ æ‰€æœ‰é•œåƒæºä¸‹è½½å‡å¤±è´¥ï¼\n")
                color.New(color.FgHiYellow).Printf("ğŸ’¡ è§£å†³æ–¹æ¡ˆ:\n")
                color.New(color.FgHiYellow).Printf("   1. æ£€æŸ¥ç½‘ç»œè¿æ¥\n")
                color.New(color.FgHiYellow).Printf("   2. ä½¿ç”¨ --ssh å‚æ•°å°è¯• SSH æ–¹å¼\n")
                color.New(color.FgHiYellow).Printf("   3. ä½¿ç”¨ --gitee-only å¼ºåˆ¶ä½¿ç”¨ Gitee\n")
                color.New(color.FgHiYellow).Printf("   4. ä½¿ç”¨ --github-only å¼ºåˆ¶ä½¿ç”¨ GitHub\n")
                color.New(color.FgHiYellow).Printf("   5. ä½¿ç”¨ --verbose æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯\n")
                color.New(color.FgHiYellow).Printf("   6. æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å­˜åœ¨: %s\n", branch)
                return fmt.Errorf("æ‰€æœ‰é•œåƒæºä¸‹è½½å¤±è´¥")
        }</span>

        <span class="cov0" title="0">color.New(color.FgHiGreen).Printf("\nâœ… æˆåŠŸä» %s ä¸‹è½½æ¨¡æ¿\n", successMirror)
        color.New(color.FgHiCyan).Printf("   ğŸ“ æºä»“åº“: %s\n", successRepoURL)
        color.New(color.FgHiCyan).Printf("   ğŸŒ¿ åˆ†æ”¯: %s\n", branch)
        color.New(color.FgHiGreen).Printf("ğŸ”„ å¤„ç†æ¨¡æ¿æ–‡ä»¶ä¸­...\n")

        // ç§»é™¤.gitç›®å½•
        gitDir := filepath.Join(tempDir, ".git")
        if utils.DirectoryExists(gitDir) </span><span class="cov0" title="0">{
                if err := os.RemoveAll(gitDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("âŒ ç§»é™¤ .git ç›®å½•å¤±è´¥: %w", err)
                }</span>
                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                        color.New(color.FgHiYellow).Printf("ğŸ—‘ï¸  å·²ç§»é™¤ .git ç›®å½•\n")
                }</span>
        }

        // ç§»é™¤å…¶ä»–ä¸å¿…è¦çš„æ–‡ä»¶
        <span class="cov0" title="0">unnecessaryFiles := []string{".github", ".gitignore", "LICENSE", "README.md"}
        for _, file := range unnecessaryFiles </span><span class="cov0" title="0">{
                filePath := filepath.Join(tempDir, file)
                if utils.DirectoryExists(filePath) || utils.FileExists(filePath) </span><span class="cov0" title="0">{
                        os.RemoveAll(filePath)
                        if verbose </span><span class="cov0" title="0">{
                                color.New(color.FgHiYellow).Printf("ğŸ—‘ï¸  å·²ç§»é™¤: %s\n", file)
                        }</span>
                }
        }

        // å¦‚æœç›®æ ‡ç›®å½•å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤
        <span class="cov0" title="0">if utils.DirectoryExists(projectName) </span><span class="cov0" title="0">{
                if err := os.RemoveAll(projectName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("âŒ ç§»é™¤å·²å­˜åœ¨ç›®å½•å¤±è´¥: %w", err)
                }</span>
                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                        color.New(color.FgHiYellow).Printf("ğŸ—‘ï¸  å·²ç§»é™¤å·²å­˜åœ¨ç›®å½•: %s\n", projectName)
                }</span>
        }

        // ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
        <span class="cov0" title="0">if err := moveDirectoryCrossPlatform(tempDir, projectName); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("âŒ åˆ›å»ºé¡¹ç›®å¤±è´¥: %w", err)
        }</span>
        <span class="cov0" title="0">color.New(color.FgHiGreen).Printf("ğŸ“ é¡¹ç›®ç»“æ„åˆ›å»ºå®Œæˆ\n")
        // åˆ›å»º.envæ–‡ä»¶ï¼Œé€šè¿‡copy .env.exampleå¾—åˆ°ï¼Œç„¶åå†æ›´æ–°
        // åˆ›å»º .env æ–‡ä»¶ï¼Œé€šè¿‡å¤åˆ¶ .env.example å¾—åˆ°
        envExamplePath := filepath.Join(projectName, ".env.example")
        envPath := filepath.Join(projectName, ".env")
        if utils.FileExists(envExamplePath) </span><span class="cov0" title="0">{
                input, err := os.ReadFile(envExamplePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("âŒ è¯»å– .env.example æ–‡ä»¶å¤±è´¥: %w", err)
                }</span>
                <span class="cov0" title="0">err = os.WriteFile(envPath, input, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("âŒ åˆ›å»º .env æ–‡ä»¶å¤±è´¥: %w", err)
                }</span>
                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                        color.New(color.FgHiGreen).Printf("âœ… å·²ä» .env.example å¤åˆ¶ç”Ÿæˆ .env æ–‡ä»¶\n")
                }</span>
        } else<span class="cov0" title="0"> {
                if verbose </span><span class="cov0" title="0">{
                        color.New(color.FgHiYellow).Printf("âš ï¸  æœªæ‰¾åˆ° .env.exampleï¼Œè·³è¿‡ .env æ–‡ä»¶åˆ›å»º\n")
                }</span>
        }

        // æ›´æ–°ç¯å¢ƒæ–‡ä»¶
        <span class="cov0" title="0">if err := updateEnvFile(projectName, projectName); err != nil </span><span class="cov0" title="0">{
                color.New(color.FgHiYellow).Printf("âš ï¸  è­¦å‘Š: æ›´æ–° .env æ–‡ä»¶å¤±è´¥: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                color.New(color.FgHiGreen).Printf("ğŸ“ å·²æ›´æ–° .env é…ç½®\n")
        }</span>

        // è¿è¡Œå‘½ä»¤è¡Œå·¥å…·ï¼Œè¿›å…¥é¡¹ç›®æ ¹è·¯å¾„ï¼Œæ‰§è¡Œgo run . artisan key:generateï¼Œä¹‹åå†æ‰§è¡Œgo run . artisan jwt:secret
        // åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹ä¾æ¬¡æ‰§è¡Œ go run . artisan key:generate å’Œ go run . artisan jwt:secret
        <span class="cov0" title="0">commands := [][]string{
                {"go", "run", ".", "artisan", "key:generate"},
                {"go", "run", ".", "artisan", "jwt:secret"},
        }

        for _, cmdArgs := range commands </span><span class="cov0" title="0">{
                cmd := utils.NewCommandWithDir(cmdArgs[0], cmdArgs[1:], projectName)
                if verbose </span><span class="cov0" title="0">{
                        color.New(color.FgHiCyan).Printf("ğŸ”§ æ‰§è¡Œå‘½ä»¤: %s\n", strings.Join(cmdArgs, " "))
                }</span>
                <span class="cov0" title="0">output, err := cmd.CombinedOutput()
                if verbose </span><span class="cov0" title="0">{
                        fmt.Print(string(output))
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        color.New(color.FgHiRed).Printf("âŒ å‘½ä»¤æ‰§è¡Œå¤±è´¥: %s\n", strings.Join(cmdArgs, " "))
                        color.New(color.FgHiRed).Printf("   é”™è¯¯ä¿¡æ¯: %v\n", err)
                        break</span>
                }
        }

        <span class="cov0" title="0">color.New(color.FgHiCyan, color.Bold).Printf("\nğŸ‰ é¡¹ç›® '%s' åˆ›å»ºæˆåŠŸï¼\n", projectName)
        color.New(color.FgHiWhite).Printf("\nğŸ“‹ ä¸‹ä¸€æ­¥æ“ä½œ:\n")
        color.New(color.FgHiGreen).Printf("   cd %s\n", projectName)
        color.New(color.FgHiGreen).Printf("   go mod tidy\n")
        color.New(color.FgHiGreen).Printf("   modify .env database configuration!\n")
        color.New(color.FgHiGreen).Printf("   air\n")
        color.New(color.FgHiYellow).Printf("\nğŸ’¡ æç¤º: ä½¿ç”¨ --verbose å‚æ•°æŸ¥çœ‹è¯¦ç»†è¾“å‡º\n")

        return nil</span>
}

// hasNextMirror æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€ä¸ªå¯ç”¨çš„é•œåƒæº
func hasNextMirror(mirrors []struct {
        name    string
        url     string
        sshURL  string
        enabled bool
}, currentMirror string) bool <span class="cov6" title="3">{
        foundCurrent := false
        for _, mirror := range mirrors </span><span class="cov10" title="6">{
                if !mirror.enabled </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov9" title="5">if foundCurrent </span><span class="cov1" title="1">{
                        return true
                }</span>
                <span class="cov7" title="4">if mirror.name == currentMirror </span><span class="cov6" title="3">{
                        foundCurrent = true
                }</span>
        }
        <span class="cov4" title="2">return false</span>
}

func updateEnvFile(projectDir, projectName string) error <span class="cov4" title="2">{
        envPath := filepath.Join(projectDir, ".env")
        if !utils.FileExists(envPath) </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov1" title="1">content, err := os.ReadFile(envPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">envContent := string(content)
        envContent = strings.Replace(envContent, "APP_NAME=Goravel", "APP_NAME="+projectName, 1)
        envContent = strings.Replace(envContent, "APP_URL=http://localhost", "APP_URL=http://localhost:3000", 1)

        return os.WriteFile(envPath, []byte(envContent), 0644)</span>
}

// moveDirectoryCrossPlatform è·¨å¹³å°çš„ç›®å½•ç§»åŠ¨å‡½æ•°
func moveDirectoryCrossPlatform(source, destination string) error <span class="cov1" title="1">{
        // å°è¯•ç›´æ¥é‡å‘½åï¼ˆåŒç£ç›˜åˆ†åŒºæ—¶æœ‰æ•ˆï¼‰
        err := os.Rename(source, destination)
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // å¦‚æœé‡å‘½åå¤±è´¥ï¼ˆå¯èƒ½æ˜¯å› ä¸ºè·¨ç£ç›˜ï¼‰ï¼Œä½¿ç”¨å¤åˆ¶+åˆ é™¤çš„æ–¹å¼
        <span class="cov0" title="0">color.New(color.FgHiYellow).Printf("âš ï¸  è·¨ç£ç›˜æ“ä½œï¼Œä½¿ç”¨å¤åˆ¶æ–¹å¼ç§»åŠ¨æ–‡ä»¶...\n")

        // åˆ›å»ºç›®æ ‡ç›®å½•
        if err := os.MkdirAll(destination, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("åˆ›å»ºç›®æ ‡ç›®å½•å¤±è´¥: %w", err)
        }</span>

        // å¤åˆ¶æ‰€æœ‰æ–‡ä»¶å’Œå­ç›®å½•
        <span class="cov0" title="0">err = filepath.Walk(source, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // è®¡ç®—ç›¸å¯¹è·¯å¾„
                <span class="cov0" title="0">relPath, err := filepath.Rel(source, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">destPath := filepath.Join(destination, relPath)

                if info.IsDir() </span><span class="cov0" title="0">{
                        // åˆ›å»ºç›®å½•
                        return os.MkdirAll(destPath, info.Mode())
                }</span> else<span class="cov0" title="0"> {
                        // å¤åˆ¶æ–‡ä»¶
                        return copyFile(path, destPath)
                }</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("å¤åˆ¶æ–‡ä»¶å¤±è´¥: %w", err)
        }</span>

        // åˆ é™¤æºç›®å½•
        <span class="cov0" title="0">if err := os.RemoveAll(source); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("æ¸…ç†æºç›®å½•å¤±è´¥: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// copyFile å¤åˆ¶å•ä¸ªæ–‡ä»¶
func copyFile(src, dst string) error <span class="cov1" title="1">{
        // æ‰“å¼€æºæ–‡ä»¶
        srcFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer srcFile.Close()

        // åˆ›å»ºç›®æ ‡æ–‡ä»¶
        dstFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">defer dstFile.Close()

        // å¤åˆ¶å†…å®¹
        _, err = io.Copy(dstFile, srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // å¤åˆ¶æ–‡ä»¶æƒé™
        <span class="cov1" title="1">srcInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return os.Chmod(dst, srcInfo.Mode())</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package utils

import (
        "os/exec"
)

// NewCommandWithDir åˆ›å»ºä¸€ä¸ªåœ¨æŒ‡å®šç›®å½•ä¸‹æ‰§è¡Œçš„å‘½ä»¤
// name: å‘½ä»¤åç§°
// args: å‘½ä»¤å‚æ•°
// dir: å·¥ä½œç›®å½•
func NewCommandWithDir(name string, args []string, dir string) *exec.Cmd <span class="cov8" title="1">{
        cmd := exec.Command(name, args...)
        cmd.Dir = dir
        return cmd
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package utils

import (
        "os"
)

func DirectoryExists(path string) bool <span class="cov10" title="6">{
        info, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov6" title="3">{
                return false
        }</span>
        <span class="cov6" title="3">return info.IsDir()</span>
}

func FileExists(path string) bool <span class="cov10" title="6">{
        info, err := os.Stat(path)
        if os.IsNotExist(err) </span><span class="cov4" title="2">{
                return false
        }</span>
        <span class="cov7" title="4">return !info.IsDir()</span>
}

func MoveDirectory(source, destination string) error <span class="cov1" title="1">{
        return os.Rename(source, destination)
}</span>

func RemoveDirectory(path string) error <span class="cov1" title="1">{
        return os.RemoveAll(path)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package utils

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os/exec"
        "path/filepath"
        "strings"
        "time"
)

func CloneRepositoryWithContext(ctx context.Context, repoURL, branch, targetDir string, verbose bool) error <span class="cov0" title="0">{
        args := []string{"clone", "--progress", "--depth", "1"}

        if branch != "" &amp;&amp; branch != "master" </span><span class="cov0" title="0">{
                args = append(args, "--branch", branch)
        }</span>

        <span class="cov0" title="0">args = append(args, repoURL, targetDir)

        cmd := exec.CommandContext(ctx, "git", args...)

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("ğŸ”§ Running command: git %s\n", strings.Join(args, " "))
        }</span>

        // è·å–æ ‡å‡†è¾“å‡ºç®¡é“
        <span class="cov0" title="0">stdoutPipe, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get stdout pipe: %w", err)
        }</span>

        <span class="cov0" title="0">stderrPipe, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get stderr pipe: %w", err)
        }</span>

        // è®°å½•å¼€å§‹æ—¶é—´
        <span class="cov0" title="0">startTime := time.Now()

        // å¯åŠ¨å‘½ä»¤
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start git clone: %w", err)
        }</span>

        // å®æ—¶è¯»å–è¾“å‡º
        <span class="cov0" title="0">go streamOutput(stdoutPipe, "git", verbose)
        go streamOutput(stderrPipe, "git", verbose)

        // ç­‰å¾…å‘½ä»¤å®Œæˆ
        err = cmd.Wait()
        duration := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                // æ£€æŸ¥è¶…æ—¶
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return fmt.Errorf("download timed out after %v", duration)
                }</span>

                // å¤„ç†ç‰¹å®šé”™è¯¯ç±»å‹
                <span class="cov0" title="0">switch </span>{
                case strings.Contains(err.Error(), "Authentication failed"),
                        strings.Contains(err.Error(), "could not read Username"),
                        strings.Contains(err.Error(), "Permission denied"):<span class="cov0" title="0">
                        return fmt.Errorf("authentication failed after %v. Try: goravel-kit-cli new %s --ssh", duration, filepath.Base(targetDir))</span>

                case strings.Contains(err.Error(), "Repository not found"):<span class="cov0" title="0">
                        return fmt.Errorf("repository not found: %s (took %v)", repoURL, duration)</span>

                case strings.Contains(err.Error(), "could not find remote ref"):<span class="cov0" title="0">
                        return fmt.Errorf("branch '%s' not found (took %v)", branch, duration)</span>

                case strings.Contains(err.Error(), "Host key verification failed"):<span class="cov0" title="0">
                        return fmt.Errorf("SSH host key verification failed. Please check your SSH configuration")</span>

                default:<span class="cov0" title="0">
                        return fmt.Errorf("git clone failed after %v: %w", duration, err)</span>
                }
        }

        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                fmt.Printf("âœ… Download completed in %v\n", duration)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("âœ… Download completed\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// streamOutput å®æ—¶æµå¼è¾“å‡º
func streamOutput(reader io.Reader, prefix string, verbose bool) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("%s: %s\n", prefix, line)
                }</span> else<span class="cov0" title="0"> {
                        // éè¯¦ç»†æ¨¡å¼åªæ˜¾ç¤ºè¿›åº¦ä¿¡æ¯
                        if strings.Contains(line, "Receiving objects:") ||
                                strings.Contains(line, "Resolving deltas:") ||
                                strings.Contains(line, "remote:") </span><span class="cov0" title="0">{
                                fmt.Printf("ğŸ“¦ %s\n", strings.TrimSpace(line))
                        }</span>
                }
        }
}

// ä¿æŒå…¼å®¹æ€§
func CloneRepository(repoURL, branch, targetDir string) error <span class="cov0" title="0">{
        return CloneRepositoryWithContext(context.Background(), repoURL, branch, targetDir, false)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package utils

import (
        "net"
        "time"
)

func CheckGiteeAccess() bool <span class="cov0" title="0">{
        timeout := 10 * time.Second
        conn, err := net.DialTimeout("tcp", "gitee.com:443", timeout)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        return true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "log"
        "os"

        "github.com/hulutech-web/goravel-kit-cli/internal/commands"
        "github.com/urfave/cli/v2"
)

func main() <span class="cov0" title="0">{
        app := &amp;cli.App{
                Name:     "goravel-kit-cli",
                Usage:    "A CLI tool to create new Goravel applications from templates",
                Version:  "v1.0.0",
                Commands: []*cli.Command{commands.NewCommand},
                Description: `Goravel Kit CLI - Quickly create new Goravel projects from template.

Examples:
  goravel-kit-cli new my-app
  goravel-kit-cli new my-app --ssh --verbose
  goravel-kit-cli new my-app --branch develop --force`,
        }

        if err := app.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
